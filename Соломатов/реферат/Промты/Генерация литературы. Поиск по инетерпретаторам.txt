Роль: Ты — эксперт в области теории типов, формальных языков и системного программирования (Compiler Engineer). Твоя специализация — проектирование предметно-ориентированных языков (DSL).

Контекст: Я занимаюсь проектированием интерпретатора для нового DSL. Мне необходимо глубокое теоретическое обоснование архитектурных решений и подборка актуальных методик реализации.

Задача: Проведи исследование и подготовь подробный технический отчет, охватывающий следующие аспекты:

1. Стандартный пайплайн реализации (Frontend)
Найди и опиши современные подходы к реализации следующих модулей:

Tokenization (Lexical Analysis): Принципы работы регулярных выражений и конечных автоматов.

CST Construction (Concrete Syntax Tree): Механика построения дерева на этапе парсинга.

Translation CST -> AST: Описание процесса очистки дерева от синтаксического шума (пунктуация, скобки) и формирования абстрактного синтаксиса.

2. Дискуссия: CST vs AST
Проанализируй и приведи обоснования, почему в современных индустриальных парсерах (например, в стиле Roslyn или ANTLR) предпочтительно строить сначала CST, а не переходить сразу к AST. Учти факторы:

Сохранение информации о форматировании (full-fidelity).

Возможность реализации Language Server Protocol (LSP) и инструментов IDE (рефакторинг, подсветка).

Упрощение обработки ошибок.

3. Паттерны проектирования
Найди статьи и опиши применение паттерна Visitor в контексте обхода деревьев (AST/CST) для реализации интерпретатора. Сравни его с подходом Pattern Matching (если применимо к современным языкам).

4. Эволюция: от Интерпретатора к Компилятору
Определи, какие дополнительные модули (Backend) должны быть добавлены в архитектуру, чтобы превратить интерпретатор в полноценный компилятор. Подробно опиши:

Intermediate Representation (IR).

Optimization Passes (Оптимизации).

Code Generation (Target: x86, LLVM IR, или Bytecode).

Требования к ответу:

Используй профессиональную терминологию.

Если возможно, сошлись на классические труды (например, "Dragon Book" Ахо/Ульмана) или современные статьи/документацию (ANTLR, LLVM, статьи инженеров JetBrains или Microsoft).

Ответ представь в виде структурированного гайда с четкими заголовками.

Почему этот промт сработает:
Разделение на модули: Мы четко разграничили этапы (лексика, синтаксис, семантика), что заставляет модель структурировать ответ по канонам Computer Science.

Проблематика (CST vs AST): Это "сильный" вопрос, который заставляет ИИ не просто давать определения, а сравнивать подходы.

Конкретика по паттернам: Упоминание Visitor сужает область поиска до конкретных реализаций обхода деревьев.

Вектор развития: Вопрос про компилятор заставляет модель описать разницу между Evaluation (выполнением) и Lowering (понижением уровня кода).